name: Deploy

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ==================== Build & Push ====================
  build:
    name: Build & Push Images
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      packages: write
    
    outputs:
      fastapi-image: ${{ steps.meta-fastapi.outputs.tags }}
      embedding-image: ${{ steps.meta-embedding.outputs.tags }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Log in to Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract FastAPI metadata
        id: meta-fastapi
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
      
      - name: Build and push FastAPI image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta-fastapi.outputs.tags }}
          labels: ${{ steps.meta-fastapi.outputs.labels }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
      
      - name: Extract Embedding metadata
        id: meta-embedding
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/embedding
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
      
      - name: Build and push Embedding image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./Dockerfile.embedding
          push: true
          tags: ${{ steps.meta-embedding.outputs.tags }}
          labels: ${{ steps.meta-embedding.outputs.labels }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/embedding:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/embedding:buildcache,mode=max

  # ==================== Staging Deployment ====================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/develop' || github.event.inputs.environment == 'staging'
    
    environment:
      name: staging
      url: https://staging.omnisearch.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to staging environment
        run: |
          echo "Deploying to staging..."
          echo "FastAPI Image: ${{ needs.build.outputs.fastapi-image }}"
          echo "Embedding Image: ${{ needs.build.outputs.embedding-image }}"
          
          # Example: Update docker-compose or kubectl deployment
          # kubectl set image deployment/fastapi fastapi=${{ needs.build.outputs.fastapi-image }} \
          #   -n staging
          
          echo "✅ Staging deployment initiated"
        continue-on-error: false

  # ==================== Production Deployment ====================
  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' && startsWith(github.ref, 'refs/tags/v')
    
    environment:
      name: production
      url: https://omnisearch.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Create deployment
        uses: actions/github-script@v6
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.ref,
              environment: 'production',
              required_contexts: [],
              auto_merge: false
            });
            console.log('Deployment created:', deployment.data.id);
      
      - name: Deploy to production
        run: |
          echo "Deploying to production..."
          echo "FastAPI Image: ${{ needs.build.outputs.fastapi-image }}"
          echo "Embedding Image: ${{ needs.build.outputs.embedding-image }}"
          
          # Example: Update Kubernetes or container orchestration
          # kubectl set image deployment/fastapi fastapi=${{ needs.build.outputs.fastapi-image }} \
          #   -n production --record
          
          echo "✅ Production deployment initiated"
        continue-on-error: false
      
      - name: Update deployment status
        uses: actions/github-script@v6
        if: always()
        with:
          script: |
            const deployment_id = context.payload.deployment.id;
            const status = '${{ job.status }}' === 'success' ? 'success' : 'failure';
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment_id,
              state: status,
              environment_url: status === 'success' ? 'https://omnisearch.example.com' : '',
              description: status === 'success' ? 'Deployment succeeded' : 'Deployment failed'
            });

  # ==================== Smoke Tests ====================
  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: always() && needs.deploy-staging.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install requests pytest
      
      - name: Run smoke tests
        run: |
          pytest tests/smoke/ -v --tb=short
        env:
          API_URL: https://staging.omnisearch.example.com
        continue-on-error: true
      
      - name: Health check
        run: |
          echo "Running health checks..."
          curl -f https://staging.omnisearch.example.com/health || true
          echo "✅ Smoke tests completed"

  # ==================== Notification ====================
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [build, deploy-staging, deploy-prod]
    if: always()
    
    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [ "${{ needs.deploy-prod.result }}" == "success" ]; then
            echo "status=✅ Production deployment successful" >> $GITHUB_OUTPUT
          elif [ "${{ needs.deploy-staging.result }}" == "success" ]; then
            echo "status=✅ Staging deployment successful" >> $GITHUB_OUTPUT
          else
            echo "status=❌ Deployment failed" >> $GITHUB_OUTPUT
          fi
      
      - name: Send Slack notification
        uses: slackapi/slack-github-action@v1.24.0
        if: always()
        with:
          payload: |
            {
              "text": "${{ steps.status.outputs.status }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Deployment Report*\n${{ steps.status.outputs.status }}\nBranch: ${{ github.ref_name }}\nCommit: ${{ github.sha }}"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
        continue-on-error: true
